---
title: "JavaScript(자바스크립트) 객체"
strapline: "Hello JS"
description: "JavaScript"
header:
 overlay_image: /assets/images/computer.jpg
categories:
  - "JavaScript"
tag:
  - "JavaScript"
toc: true
last_modified_at: 2019-12-06
comments: true
---

## 자바스크립트 객체


**객체 - Object!**<br>

자바스크립트에서는 자바나 다른 객체지향 언어와는 다르게 클래스라는 개념이 없고 별도의 생성 방식이
존재한다. 생성 방식에는 3가지가 존재한다. <br>

&nbsp; 1. Object() 객체 생성자 함수를 이용하는 방법<br>
&nbsp; 2. 객체 리터럴 방식 이용<br>
&nbsp; 3. 생성자 함수 이용<br>

먼저 아래에 있는 예제는 Object() 함수를 이용한 객체 생성 방법이다. 주의할점은 Object() 함수 사용시 
앞에 new 연산자를 꼭 써줘야 한다.<br>

![js-1](/assets/images/js-5.jpg)<br>

두번째로 객체 리터럴 방식이다. 객체 리터럴은 중괄호({ })를 이용해서 객체를 생성한다.<br> { } 안에 아무것도
적지 않은 경우는 빈 객체가 생성되며, 중괄호 안에 "프로퍼티 이름 : 프로퍼티값" 형태로 표기한다.<br>
프로퍼티 이름은 문자열이나 숫자가 올 수 있다. 프로퍼티값으로는 어떠한 표현식도 올 수 있고 이 값이
함수일 경우 메서드(method)라고 부른다.<br>

![js-1](/assets/images/js-6.jpg)<br>

마지막으로 생성자 함수 이용 방법이다. 함수를 통해서 객체를 생성하는 방법인데, 함수를 다룰 때 다시
설명하겠다.<br>

**객체 프로퍼티 읽기/쓰기/갱신**<br>

객체의 프로퍼티에 접근하려면 다음과 같이 두 가지 방법을 사용한다.<br>

&nbsp; 대괄호([ ]) 표기법<br>
&nbsp; 마침표(.) 표기법<br>

![js-1](/assets/images/js-7.jpg)<br>

**프로퍼티 동적 생성**<br>

자바스크립트에서는 객체가 생성된 후에도 동적으로 프로퍼티를 생성해서 해당 객체에 추가할 수 있다.

![js-1](/assets/images/js-8.jpg)<br>

**대괄호 표기법만을 사용해야 하는 경우**<br>

접근하려는 프로퍼티가 표현식이거나 예약어일 경우 마침표 표기법으로는 접근할 수 없다.<br>아래 예제에서처럼
'java-script' 프로퍼티의 경우 '-' 연산자가 있는 표현식이다. 이 경우 대괄호 표기법만을 이용해서 
프로퍼티에 접근해야 한다.<br>

![js-1](/assets/images/js-9.jpg)<br>

위의 예제에서 결과값이 NaN(Not a Number)값이 출력됐는데, NaN값은 수치 연산을 해서 정상적인 
값을 얻지 못할 때 출력되는 값이다. 'java-script' 프로퍼티에 접근하려는 의도와 다르게 obj.java와 
script라는 변수의 값을 '-' 연산자로 계산하는 표현식으로 취급했기 때문이다.<br> 

**객체 프로퍼티 삭제**<br>

객체의 프로퍼티를 delete 연산자를 이용해 즉시 삭제할 수 있다. 하지만 객체의 프로퍼티를 삭제할 뿐,
객체 자체를 삭제하지는 않는다.<br>

**객체 열거 방법**<br>

for in 문을 사용하면, 객체에 포함된 모든 프로퍼티에 대해 루프를 수행할 수 있다. 아래 예제처럼 for in 문이 수행되면서 변수 i에 obj_ 객체의 프로퍼티가 하나씩 할당된다. 또한 대괄호 표기법을 이용하면 프로퍼티값을 출력할 수 있다.

![js-1](/assets/images/js-13-1.jpg)<br>

![js-1](/assets/images/js-13-2.jpg)<br>

**Call by Reference vs Call by Value**<br>

4장에서 예고한바와 같이 객체는 실제값을 저장하지 않고 '참조값'을 저장한다. 이는 값에 의한 호출(Call by Value)
방식으로 동작하는 기본타입과의 차이점이다.<br>기본 타입의 경우 함수를 호출할 때 기본 타입의 값이 인자일 경우 호출 된
함수의 매개변수로 '복사된 값'이 전달되므로 함수 내부에서 매개변수를 이용해 값을 변경하려고 해도 변경되지 않는다.<br>
반면 함수의 인자를 참조타입으로 넘길 경우 객체의 실제값이 함수의 매개변수로 복사되지 않고 참조값이 그대로 함수 내부로
전달된다.<br>다음 예제는 기본타입과 참조타입의 차이점을 확실히 보여준다.<br>changeArg() 함수를 호출하면서, 인자값으로
기본 타입인 숫자를 가진 변수 a와 참조 타입인 객체 objA를 넘겼다.<br>함수 내부에서 매개변수 num과 obj를 이용해 인자로 전달된
a와 objA.val의 값을 100에서 200으로 바꿨지만, 함수 호출이 끝난 후에는 참조 타입인 객체의 objA.value 프로퍼티만이 실제 값으로
변해있다는 것을 확인할 수 있다.<br>

![js-1](/assets/images/js-10.jpg)<br>

![js-1](/assets/images/js-11.jpg)<br>

**객체 비교**<br>

기본 타입의 경우는 동등 연산자(==)를 이용해서 비교할 때 값을 비교한다. 하지만 객체를 비교할 때는
동등 연산자(==)를 사용하여 객체의 실제값이 아닌 참조값을 비교하므로 주의해야 한다. <br>

**프로토타입(Prototype)**<br>

자바스크립트의 모든 객체는 자신의 부모 역할을 하는 객체와 연결되어 있다. 객체지향 언어의 상속 개념과 같이 부모 객체의
프로퍼티를 마치 자신의 것처럼 쓸 수 있다. 이러한 부모 객체를 프로토타입(Prototype)이라고 부른다. <br>

![js-1](/assets/images/js-12.jpg)<br>

prot 객체에 toString()이라는 메서드가 없으므로 에러가 발생해야 하지만 정상적으로 결과가 출력됐다. 이는 prot 객체의
프로토타입에 toString() 메서드가 이미 존재하기 때문에 마치 자신의 것처럼 호출했기 때문에 에러가 발생하지 않았다.<br>
모든 객체는 자신의 프로토타입을 가리키는 &#95;&#95;proto&#95;&#95;(혹은 [[Prototype]])라는 숨겨진 프로퍼티를 가지고 있어서 언제든 
부모 객체(prototype)의 프로퍼티를 가져다 쓸 수 있다.


